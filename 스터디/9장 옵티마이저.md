## 개요
### 쿼리 실행 절차
1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
	-  `SQL 파서`가 처리 및 문법 검증 및 파스 트리 생성
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
	- `옵티마이저` 에서
		- 불필요한 조건 제거 및 복잡한 연산의 단순화
		- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
		- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
		- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
	- `실행 계획` 생성
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
	- `스토리지 엔진` 에서 `실행 계획`으로 요청. 
	- 레코드 읽고 조인, 정렬 작업 수행
### 옵티마이저의 종류
- 두뇌와 같은 역할
- #### 비용 기반 최적화(MySQL 픽)
	- 여러가지 가능한 방법 중 단위 작업 비용과 테이블의 통계 정보를 이용하여 비용을 산출한다.
	- 최소 비용으로 처리되는 방식을 선택
- #### 규칙 기반 최적화
	- 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
	- 같은 쿼리는 같은 실행 계획
	- 데이터의 분포가 다양하기 때문에 DBMS에서 거의 사용되지 않음
## 기본 데이터 처리
### 풀 테이블 스캔과 풀 인덱스 스캔
#### 풀 테이블 스캔 조건
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔하는 편이 빠른 경우(테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)
#### 풀 테이블 스캔 특징
- 대부분의 DBMS는 풀 테이블 스캔할 때 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.(InnoDB도 마찬가지)
	- Read ahead : 데이터가 앞으로 필요할 것을 예측하여 디스크에서 읽어 InnoDB 버퍼 풀에 둔다.(백그라운드에서 실행)
		- 옵션으로 실행 시점의 임계값을 설정할 수 있다.
		- 풀 인덱스 스캔에서도 동일하게 사용된다.
- `SELET count(*) FROM employees;` 
	- 풀 테이블 스캔을 하지 않고 풀 인덱스 스캔을 한다.
		- 인덱스는 특정 컬럼에만 걸려있기 때문에 전체 테이블보다 인덱스 페이지의 크기가 작다.
### 병렬 처리

