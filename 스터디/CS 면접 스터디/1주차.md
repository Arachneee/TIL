# 객체지향
- 객체지향프로그래밍을 하는 이유가 뭐라고 생각하시나요?
	- 유지보수에 용이한 코드를 작성하기 위해서입니다.
	- 왜 유지보수에 용이한 코드를 작성해야할까요?
		- 요구사항이 항상 변경되면서 변경에 용이한 코드를 작성해야한다.
		- 로직이 점점 복잡해지면서 코드의 양이 방대해졌고 여러 사람이 함께 오랜 시간동안 코드를 사용해야 하기 때문입니다.
	- 어떻게 유지보수를 용이하게 만드나요?
		- 객체들의 의존성을 적절하게 조절해서 결합도와 응집도를 관리합니다.
		- 로직과 상태를 객체 단위로 관리하면서 책임과 역할을 분리해서 재사용성을 높인다.
		- 하나의 변경에 하나의 클래스만 바라볼 수 있도록 하여 다른 코드에 영향을 줄입니다.

- 객체지향의 단점은 무엇인가요?
	- 객체 그래프 탐색으로 성능 저하가 발생할 수 있다.

- 5대 원칙이 뭐가 있죠?
	- SRP(Single Responsibility Principle) : 단일 책임 원칙  
	    클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
	 - OCP(Open-Closed Principle) : 개방-폐쇄 원칙  
		    확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
	- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙  
	    상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
	- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙  
	    인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
	- DIP(Dependency Inversion Principle) : 의존 역전 원칙  
	    고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
	    
- 프로젝트에서 모두 객체지향을 준수해서 설계를 하셨나요?
	- 노력은 했지만 완벽하다고는 할 수 없습니다. 단일책임원칙을 지키기 위해 클래스를 분리하는 것도 좋지만 현재 프로젝트의 규모를 생각해여 분리하지 않은 부분도 있습니다. 
	- 객체지향을 하는 이유가 유지보수에 용이하게 하기 위함으로 생각하기 때문에 현재 프로젝트의 규모를 생각하지 않고 무분별한 클래스 분리는 복잡도를 높일 수 있다고 생각합니다.

# Restful API
- rest api가 무엇인가요?
	- Resource Oriented Architecture : API가 Http Method로 자원을 처리하는 설계
	- 리소스와 행위를 명시적이고 직관적으로 분리한다.
	- header와 body를 명확히 분리해서 사용한다.
	- API 버전을 관리한다.
	- 서버와 클라이언트가 같은 방식을 사용해서 요청한다.
- rest api 6가지 설계 원칙
	- 균일한 인터페이스
	- 클라이언트-서버 분리
	- 무상태
	- 캐시 가능성
- Restful API는 왜 사용할까요?
	- 규칙을 정해놓음으로서 API의 의미를 유추하기 쉽다.
	- Open API를 제공하기 쉽다.
- 단점으로는 무엇이 있을까요?
	- 사용할 수 있는 메소드가 한정적이다.
- 프로젝트에서 만든 API 들은 모두 restful api 인가요?
	- 아니요. restful api와 유사하게 만들었지만 규칙과 다른 부분도 존재합니다. 하지만 이런 restful api 를 만든 이유가 서로 소통을 원활하게 하기 위함이라 생각합니다. restful하지는 않지만 소통을 하는데 있어 어려움은 없었습니다.

# 자료 구조
## Array vs Linked List
- Array list 와 linked list의 차이가 무엇인가요?
	- array list는 논리적 저장 순서와 물리적 저장 순서가 일치합니다. 그래서 stack으로 사용할 수 있고 제일 뒤에 삽입 삭제할 경우와 인덱스로 읽는 경우에는 O(1)이 걸리고 중간에 삽입, 삭제의 경우 O(n)까지 걸릴 수 있습니다.
	- 반면에 Linked list는 자신의 다음 원소가 어떤 원소인지 기억하는 자료구조입니다. 따라서 삽입, 삭제시 다음 원소만 변경하면 되므로 O(1)로 해결할 수 있습니다. 하지만 원하는 위치에 삽입하려면 서치 과정이 필요하기 때문에 O(n)의 시간이 추가적으로 발생합니다.
- 그러면 linked list 언제 사용해야할까요?
	- Tree 구조의 근간으로 Queue 같은 자료구조를 이용할 때 사용합니다.
## Stack and Queue
- stack이 무엇인가요?
	- Last in first out
	- 나중에 들어온 원소가 먼저나오는 자료구조입니다.
- Queue가 무엇인가요?
	- first in first out
	- 처음들어온 원소가 먼저나오는 자료구조입니다.
## Tree
- binary tree 의 시간복잡도가 어떻게 되죠?
	- O(log n)
## BST (Binary Search Tree)
- 탐색의 시간복잡도는 O(log n) 이지만 편향트리가 되는 Worst case는 O(n)이 된다.
- rebalancing 으로 트리 구조를 재조정한다.

## Binary Heap
- 최대 or 최대를 찾는데 O(1), 원소 추가시 O(log n)

## Red Black Tree

## Hash Table
- O(1)으로 찾을 수 있다.
- hash 함수 : key값이 중복될 수 있다. 충돌을 최소화하고 충돌이 발생하면 그 때 해소한다.
### Conflict 해결 방법
- Open Address (개방 주소법)
	- 다른 해시 버킷에 해당 자료를 삽입한다.
	- 최악의 경우 비어있는 버킷을 찾지 못하고 시작위치로 돌아온다.
		- Linear Probing 순차 탐색
		- Quadratic probing 2차 함수로 탐색 위치를 찾는다.
		- Double hashing probing 2차 해쉬 함수를 이용해 새로운 주소 할당.
- Separate Chaining (분리 연결법)
	- Open Address보다 빠르다.
		- 해시 버킷을 채운 밀도가 높아질 수 록 Worst Case 발생 빈도가 높아진다.
	- Java 7, HashMap에서 사용.
	- 구현 방식
		- Linked List : 버킷들을 연결리스트로 만들어 충돌이 발생하면 해당 bucket의 list에 추가하는 방식이다.
		- Red-Black Tree : 트리 구조 사용. 데이터 개수가 많을 때 사용.
- 키-값 쌍의 개수가 6개 8개 기준으로 데이터가 적으면 링크드 리스트, 많으면 트리를 사용한다.
- 데이터가 충분히 적으면 Open Address 방식이 캐시효율이 높아 성능이 좋다.
- Separate Chaining 방식은 테이블의 확장을 늦출 수 있다.

## Graph
- 정점과 간선의 집합
- 트리 : 사이클이 허용되지 않는 그래프
- Degree : 정점(vertex)에 연결된 edge의 개수
### 그래프 구현 방법
- 인접 행렬
	- V^2의 공간으로 연결관계를 표현한다. O(1)으로 연결관계를 파악할 수 있다.
- 인접 리스트
	- O(E + V) 의 공간이 필요하다.
### 그래프 탐색
- DFS : O(V + E) 시간 복잡도
- BFS : O(V + E) 시간 복잡도
- Minimum Spanning Tree : 모드 vertex가 cycle이 없이 연결된 형태의 그래프에서 edge weight의 합이 최소인 그래프.
- Kruskal algorithm : weight가 가장 작은 edge부터 검토하여 cycle이 생기지 않게 한다.
- prim algorithm : 외부의 가장 작은 weight의 edge를 통해 연결되는 vertex를 추가한다. edge의 weight를 기준으로 연결한다.