- 테스트시 고려사항
    - 무엇을 검증하고 싶은지?
    - 검증하고 싶은 범위가 어떤지?
    - 실제 객체를 사용할 것인지? 가짜 객체를 사용할 것인지?

- tdd : 아는 것에서 모르는 것으로 뱡향으로 설계
    - 모든 부분을 TDD로 해야하는 강박을 버리자

- stub : 객체의 행위만 미리 설정한다.
- fake : 가짜 객체
    - Test에서 Fake 객체를 사용하면 유지보수하기 어려워진다. 
- mock : 객체의 메소드를 호출을 했냐? 몇 번 호출했냐를 검증
	- Mockito
Void 반환 O
```java
doThrow(IllegalStateException.class).when(dictMock) .add(anyString(), anyString());
```
Void 반환 X
```java
when(dictMock.getMeaning(anyString())).thenThrow(NullPointerException.class);
```


- 테스트를 어디까지 해야할까?
    - 통합테스트, 서비스테스트, 레포지토리테스트를 전부 수행하면 중복되는 테스트가 매우 많아 진다.
    - 객체를 분리하거나 필드를 추가하면 변경사항이 너무 많다.
    - 테스트가 있으면 나중에 유지보수하기에 좋다고 했는데 기능이 추가되면서 유지보수할 테스트코드가 너무 많아진다.
    - 정작 구현하고자 하는 기능보다 이전 테스트코드 리펙토링에 리소스를 많이 소모하게된다.

- 테스트의 우선순위
    - 도메인 테스트가 1순위
    - 통합테스트: 전체 코드를 커버할 수 있다.(최종 목표다.) 에러를 찾기 어렵다.
    - 서비스테스트: 비지니스 로직이 포함되어있다.
    - 레포지토리테스트: SQL오류는 빨리 파악가능하다. 하지만 오류가 가장 많이 나는 부분이다.

    - 내 생각 순위 : 도메인 -> 서비스 -> 통합 -> 레포지토리

- data.sql로 테스트 전체를 구성하면 유지보수에 좋지 않다.
- 테스트 롤백하거나, 클린업하는 방법 말고도 다른 키를 사용하는 방법도 있다.

- SpringBootTest
    - mock : 톰켓이 없고 통신이 dispatcher servlet으로 넘어감
    - none과 큰 차이 없다.
- restaured 는 쓰레드가 달라서 트렌젝션이 안먹는다. 세션 설정을 못한다.

