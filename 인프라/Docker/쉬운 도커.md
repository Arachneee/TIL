### 가상화 기술
- 실제로 존재하는 컴퓨터가 아니지만 마치 존재하는 것처럼 만들어주는 기술
- 한대의 컴퓨터에 가상환경의 여러 컴퓨터를 만들 수 있다.
- 하나의 프로그램이 다른 프로그램에 영향을 주지 않게 한다.
- 하이퍼바이저 가상화 방식(VMware 등)
	- 호스트 OS의 자원을 격리해서 새로운 OS를 실행한다. 논리적으로 OS를 격리한다.
	- 하이퍼바이저가 다른 게스트 OS가 호스트OS 커널을 사용할 수 있도록 바꿔준다.
- 컨테이너 가상화
	- 하이퍼바이저보다 가볍고 빠르다.
	- LXC 기술로 커널 자체기능으로 격리 공간을 만들 수 있다.
	- LXC로 격리된 공간이 컨테이너다.
	- 호스트 OS의 커널을 공유하기 때문에 적은 오버헤드로 빠르게 실행할 수 있다.
	- 호스트 OS와 다른 종류의 OS는 실행할 수 없다. 커널을 공유하기 때문.

### 아키텍처
- 컨테이너 엔진과 컨테이너 런타임으로 구분된다.
	- 컨테이너 런타임 : runc (OCI 표준 구현)
- 클라이언트-서버 모델
- Docker Daemon을 실행하기 위해서는 API로 http 통신을 해야하는데 불편하다.
	- 그래서 Docker CLI로 명령어를 실행할 수 있게 제공한다.

### 이미지와 컨테이너
#### 이미지
- 특정 시점의 파일시스템(디렉터리)를 저장한 압축 파일
- 실행 가능한 소프트웨어 + 실행에 필요한 환경
- 디스크 공간 차이
- 메타데이터
	- env : 소프트웨어가 실행 시 참조할 설정 정보
	- cmd : 컨테이너 실행 시 프로세스 실행 명령어 지정
#### 컨테이너
- 실행 상태의 이미지
- 이미지 1 : N 컨테이너
- 컨테이너로 실행 시 CPU, MEM 등의 리소스 사용
- 컨테이너 간 리소스 격리
- 실행시 이미지를 복사해 격리된 디스크 공간 생성
- 컨테이너 실행 시 프로세스도 함께 실행

##### 컨테이너 라이플 사이클

![[스크린샷 2024-07-13 오전 9.24.32.png]]
- 일시 정지 상태 : CPU X, 메모리 O
- 종료 : CPU X, 메모리 X

### 이미지 레지스트리
- 기능
	- 이미지 공유
	- 이미지 검색
	- 이미지 버전 관리
	- 보안
	- 파이프라인
	- 
- 이미지명 규칙
	- 레지스트리주소/프로젝트명/이미지명:이미지태그
		- 기본값 : (docker.io)/(library)/이미지명/:(latest)

### 이미지 빌드
#### 이미지 레이어
이미지는 레이어로 구분된다.
- 재활용에 유리
- 이전 레이어의 변경사항이 저장
- 중복데이터 최소화
- 빌드 속도 향상
- 저장소 효율화
#### 컨테이너 레이어
- 컨테이너 실행 시 읽기, 쓰기 가능한 새로운 레어어 추가
- 다음 레이어에서 이전 레이어의 특정 파일을 수정 할 때, 해당 파일의 복사복을 만들어서 변경 사항을 적용
	- 불변 레이어
#### 이미지 생성 방법
- 커밋
	- 현재 상태의 컨테이너의 상태를 이미지로 저장
		- 기존 이미지(읽기 전용)에 컨테이너 이미지(읽기 & 쓰기) 추가하여 새로운 이미지를 생성한다.
- 빌드
	- Dockerfile을 통해 이미지를 저장
	- 문법
		- FROM {이미지명} : 베이스 이미지 지정
		- COPY {파일경로} {복사할 경로} : 파일을 레이어에 복사 (새로운 레이어 추가)
		- RUN {명령어} : 명령어 실행 (새로운 레이어 추가)
		- CMD ["명령어"] : 컨테이너 실행 시 명령어 지정
		- WORKDIR {폴더명} : 작업 디렉토리 지정
		- USER {유저명} : 명령을 실행할 사용자 변경
		- EXPOSE {포트번호} : 컨테이너가 사용할 포트를 명시
		- ARG {변수명} {변수값} : 이미지 빌드 시점의 환경 변수 설정(실행 시점에는 적용되지 않는다.)
		- ENV {변수명} {변수값} : 이미지 빌드 및 컨테이너 실행 시점의 환경 변수 설정
		- ENTRYPOINT ["명령어"] : 고정된 명령어 지정
			- 보안적으로 임의의 cmd 실행을 막을 수 있다.
	- Dockerfile 있는 폴더의 파일이 도커 데몬에 전달된다.
		- .dockerignore 로 전달하지 않을 파일을 선택할 수 있다.
	- 어플리케이션 빌드 과정이 필요할 수 있다.
- 멀티 스테이지 빌드
	- 어플리케이션 실행을 위해서는 build된 jar 파일만 있으면 되지만 build를 위한 세팅이 필요하다.
	- 어플리케이션 build를 위한 세팅을 따로 분리하는 기술
	- build를 위한 소스코드, 라이브러리, 실행파일을 제거하여 용량을 줄인다.

### 컨테이너 애플리케이션 구성
- 어플리케이션 컨테이너와 DB 컨테이너 연결
	- applicatio.yml 파일에 datasource.url을 작성해야한다.
	- 이때 DB 컨테이너의 이름을 적으면 Docker DNS가 ip를 동적으로 매핑해준다.
	- docker run -d -p 8080:8080 -e DB_URL=leafy-postgres --network --name leafy jhg2819/laefy-backend:1.0.0

### 네트워크
- 공인IP, 사설IP로 분류된다.
- NAT : 공인 IP와 사설 IP, 포트를 매핑해둔다. 랜덤한 포트를 설정해둔다.
- 포트포워딩 : 외부에서 사내로 접근할 때 랜덤한 포트면 찾아갈 수 없으므로 사용자가 지정해둔 포트로 변환해준다.
- 내부 DNS 서버도 있다.

#### 가상 네트워크
- 1대의 서버에서 가상으로 정의된 네트워크
- SDN(Software Defined Network)
	- 가상의 네트워크 브릿지 생성
	- 컨테이너마다 가상의 IP 할당
- iptables : Linux 내부의 네트워크 트래픽 관리 및 제어
- 컨테이너 1개 당 Host머신에 가상의 Veth 인터페이스 1개 생성
- Docker가 iptables의 규칙을 수정하여 Veth 인터페이스의 트래픽 제어
- 컨테이너는 같은 브릿지끼리만 통신할 수 있다.
- docker dns
	- 컨테이너이름으로 ip가 저장되어있다.
	- 기본 bridge는 DNS기능이 없다.

### 도커 볼륨
- 컨테이너는 Stateless
	- 저장 및 공유가 필요한 데이터는 외부에서 저장
	- 캐시 서버나 쿠키를 통해 관리
	- 동일한 요청은 동일한 결과
	- 설정을 외부에서 주입
- 컨테이너의 영속성
	- 필요한 데이터를 외부 공유 저장소(볼륨)에 저장한다.
	- 컨테이너의 특정 폴더를 공유 폴더로 만든다.
- 마운트
	- 볼륨에 연결

### 도커 실무
#### 레이어 관리
- Docker 파일에서 명령어 하나에 1개의 이미지 레이어가 생긴다.
- RUN 명령어의 경우 && \ 로 하나의 명령어로 이어주는 것이 좋다.
- 이미지의 크기를 작게 관리하는 것이 네트워크 비용을 낮춘다.
- alpine OS를 사용하면 이미지 크기를 줄일 수 있다.
- .dockerignore 로 불필요 데이터를 제외하자.
#### 캐싱
- 각 단계의 결과 레이어를 캐싱한다.
- 지시어가 변경되지 않으면 다음 빌드에서 재사용한다.
- 이전 레이어가 변경되면 다음 레이어도 변경된다.
- 개발시 잘 변경되지 않는 레이어를 아래에 배치하면 캐시를 활용할 수 있다.