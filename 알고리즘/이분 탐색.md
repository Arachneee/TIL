1. [left, right]가 Check(left) != Check(right)가 되도록 구간을 설정 
	- **첫 범위에 반듯이 F인 범위가 하나는 있어야한다.**
2. while (**left + 1 < right**)동안 mid = (left + right) / 2에서 Check(mid) = Check(left)라면 **left = mid**, 아니라면 **right = mid**
3. 구한 경계에서 답이 left인지 right인지 생각해보고 출력
    
(1에서 경계는 항상 [lo, hi] 내에 존재하고, 2에서 Check(lo), Check(hi)는 변하지 않으며, 3에서 lo + 1 >= hi이고, lo < mid < hi에서 lo < hi이므로 lo + 1 == hi를 만족합니다)

#### 주의사항
1. left, right는 항상 정답의 범위를 나타낼 수 있도록 해야합니다. 예를 들어 left를 출력해야 하는 문제의 답이 최대 n일 때 right = n으로 선언하거나, right를 출력해야 하는 문제의 답이 최소 0일 때 left = 0으로 선언하면 안됩니다. (**right = n + 1**, **left = -1**로 선언해야 합니다)
2. 오버플로우에 주의해야 합니다. 이분 탐색을 사용하는 문제는 대부분 수의 범위가 크기 때문에 오버플로우가 발생할 수 있습니다.
3. 결정 문제의 정의에 맞게 Check함수를 잘 구현해야 합니다. 예를 들어 lower_bound는 v[i] >= k인 i의 최솟값을 구하는 함수이고, upper_bound는 v[i] > k인 i의 최솟값을 구하는 함수인데, Check 함수의 부등호를 조금만 틀려도 전혀 엉뚱한 값이 튀어나올 수 있습니다.

##### 첫 범위에서 F인 범위를 선택할 수 없는 경우 : 인위로 하나 더 추가, 계산후 한칸 더 고려 
##### 배열이 여러개면 합쳐서 이분탐색을 할 수 있게 만들자.
##### 배열이 1개면 분리해서 이분탐색을 할 수 있게 만들자.

