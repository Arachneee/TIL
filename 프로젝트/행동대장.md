- Java
	- java 17 버전을 사용한 이유? (11, 21 과의 차이점)
		- LTS로 안정적이고 장기적 지원을 해준다.
		- 널리 사용되는 버전으로 검증된 버전이다.
		- Records를 통해 DTO를 더 효율적으로 사용할 수 있다.
		- Spring Boot 3.xx 버전과의 호환성의 최신 기술과 성능을 최대한 활용할 수 있다.
- Spring Boot
	- 버전 3을 사용한 이유? (2와의 차이점)
		- 차이점 : Java17 이상을 요구함, Jakarta EE 9로 전환
		- GraalVM Native Image 지원으로 애플리케이션 시작 시간 단축, 메모리 사용량 최적화
	- Spring Boot를 사용한 이유? (Spring 과의 차이)
		- Auto-configuration
			-  @SpringBootApplication : 빈 자동 등록
			- 의존성 관련 필요한 빈 자동 등록
		- 내장 웹서버
		- 개발 속도와 배포 간편성 향상
		- 스타터 패키지 제공
		- Actuator 제공
	- Spring Boot Actuator를 사용해본 적이 있나요? 어떤 모니터링 지표를 확인했나요?
		- Health check를 이용한 로드밸런싱
		- 힙메모리 사용량
			- 이미지 업로드
		- GC 초당 발생횟수
			- 이미지 업로드
		- Http 요청 응답 시간
			- 성능측정
		- CPU 사용량
		- 스레드 풀 상태
- Spring 을 사용한 이유
	- 생산성
	- 확장성
		- DI와 AOP로 쉽게 유지보수하고 확장할 수 있다.
	- 안정성
- JPA
	- JPA를 사용한 이유? (Mybatis나 Spring JDBC와의 차이점)
		- 데이터베이스 작업의 단순화
		- 객체지향 개발 지원
			- Hibernate의 cascade, orphanremoval 등의 기능을 활용해서 객체 관점에서 코드를 작성하기 용이했다.
		- Lazy, Eager로 성능최적화
	- N+1 문제를 해결한 경험이 있나요? 어떻게 해결했나요?
		- 조회시 쿼리가 100번나가는 문제가 있었는데 1번으로 줄였다. 
		- fetch join을 사용해서 필요한 데이터를 한번에 가져올 수 있게 했습니다.
		- batch size를 조절하여 필요한 데이터를 in 절로 한번에 가져올 수 있게 했습니다.
	- Lazy Loading과 Eager Loading 차이점은 무엇인가요?
		- 필요한 시점에 쿼리를 날리는 방식
		- 즉시 쿼리를 날려서 가져오는 방식
	- JPA에서 Entity Lifecycle에 대해 설명할 수 있나요?
		- 비영속
		- 준영속
		- 영속
		- 삭제
- Mysql
	- RDBMS를 사용한 이유? 
		- 데이터의 무결성을 위해 사용했다.
		- ACID
			- 원자성 : 모든 작업이 완전히 실행되거나 전혀 실행되지 않아, 실패 시 데이터의 일관성을 유지할 수 있습니다.
			- 일관성 : 트랜잭션 실행 전후로 데이터베이스가 항상 일관된 상태를 유지합니다.
			- 고립성 : 동시에 여러 트랜잭션이 실행되더라도 서로 간섭하지 않으며, 독립적으로 처리됩니다.
			- 지속성 : 트랜잭션이 성공적으로 완료된 후에는, 시스템이 다운되더라도 데이터는 영구적으로 저장됩니다.
	- Mysql을 사용한 이유? (Oracle이나 Postgres와의 차이점)
		- Oracle은 비용이 높다.
		- 읽기 중심 어플리케이션에서 최적화
		- Mysql이 Postgres보다 쓰기 성능이 좋다.
	- 인덱스 최적화를 어떻게 했나요?
		- 커버링 인덱스를 사용하여 디스크 I/O를 최소화 한다.
		- 카디널리티가 높은 컬럼을 첫번째에 두기
	- 쿼리 성능 개선을 위해 어떤 방법을 사용했나요?
		- 쿼리 실행 계획을 분석해서 조인 쿼리를 서브쿼리로 변경했다.
- CI/CD
	- CI가 필요한 이유?
		- 자동화된 테스트를 통해 오류를 빠르게 판단할 수 있다.
		- 빠른 코드 통합에 도움을 준다.
		- 4명이서 개발을 할 때 서로 코드리뷰를 하기에 시간이 부족한 경우가 있었다. 이때 CI를 통해 코드에 에러는 없다는 것을 1차적으로 검증할 수 있어서 협업에 용이했다.
		- 또한 작은 실수도 자동화 테스트를 통해 잡을 수 있어 빠른 피드백에 도움을 주었다.
		- 생산성 향상에 도움을 주었다.
	- CD가 필요한 이유?
		- 매번 인스턴스에 접근해서 배포하는 것의 불편함을 느꼈습니다.
		- 빠른 배포 자동화로 기능을 추가하고 피드백 받는 사이클을 줄였습니다.
	- github Actions를 사용한 이유? (젠킨스, CodeDeploy와의 차이점)
		- 빠른 MVC를 개발해야하는 상황에서 러닝커브가 적고 빠르게 구축할 수 있는 github actions를 선택했습니다.
		- 젠킨스의 경우 훨씬 규모가 큰 프로젝트에서 복잡한 파이프라인을 구성해야할 때 좋다.
		- Code Deploy는 AWS 인프라와의 통합에 유리하고 무중단 배포, 롤백 기능을 제공하여 간편하다.
	- Github Actions에서 멀티스테이지 파이프라인을 구성한 경험이 있나요?
		- github actions로 블루그린 무중단 배포를 구성한 경험이 있습니다.
	- CI/CD 파이프라인을 어떻게 구성했나요?
		- github actions를 사용하여 CI는 테스트 코드를 돌리게하였습니다.
		- CD는 github actions에서 build 후 docker image로 build후 docker hub에 올린다.
		- ec2에서  docker hub 에서 image를 pull 받은 후 컨테이너를 실행시킨다.
- AWS
	- CloudFront를 사용한 이유?
		- 정적페이지를 캐싱해, 사용자와 가까운 위치에 빠르게 콘텐츠를 전달할 수 있다. (CDN)
		- Anti-DDos 로 기본 보안 기능을 제공한다.
		- ACM을 활용하여 HTTPS 쉽게 설정할 수 있다.
	- ALB를 사용한 이유?
		- 부하 분산하여 가용성을 확장하기 위해 사용했다.
	- ALB와 NLB의 차이점은 무엇인가요?
		- ALB는 HTTP 트레픽에 최적화 되어있다.
		- NLB는 TCP/UDP 기반 로드 벨런싱에 적합하다.
	- S3를 사용한 이유?
		- 고가용성과 내구성으로 데이터 안정성이 높다.
		- 백업 및 정적파일 제공, 서비리스 어플리케이션 통합에 유리하다.
	- S3에서 데이터의 내구성과 가용성을 어떻게 보장하나요?
		- 데이터를 여러 가용영역에 복제하여 내구성을 높인다.
	- VPC가 무엇인지?
		- 사용자가 정의한 가상 네트워크 환경
		- 논리적으로 분리된 네트워크 설정, 구성, 보안, 접근 제어
		- 보안 그룹
			- 인바운드/아웃바운드 트래픽을 제어
			- 
	- VPC Peering을 설정한 경험이 있나요?
		- 두개의 VPC를 직접연결하여 리소스가 통신을 가능하게 한다.
	- 서브넷이 무엇인지?
		- VPC 내의 네트워크를 서브넷으로 분할하여 구성
		- public, private 서브넷으로 구분
	- IGW가 무엇인지?
		- 공용 서브넷의 리소스가 인터넷과 통신할 수 있도록 연결하는 게이트웨이
	- NAT이 무엇인지?
		- private 서브넷에 있는 리소스가 인터넷에 연결할 수 있지만, 외부에서 접근 불가능하게 하는 게이트 웨이
	- READ / WRITE db를 분리한 이유?
		- 어플리케이션 특성 상 READ / WRITE 요청의 비율이 4 : 1 정도로 READ 요청이 많다. 이 트래픽을 분리하기 위해 READ/WRITE DB를 분리했다.
		- 쓰기(write) 작업은 트랜잭션, 인덱스 업데이트, 동기화 등으로 상대적으로 시간이 오래 걸립니다.
			- WRITE db에 장애가 발생해도 복제본으로 서비스를 할 수 있다.
- Nginx
	- nginx를 사용한 이유?
		- 처음에 사용한 이유는 https 인증을 하기 위해 설정했지만 ALB를 달고 CloudFront 의 ACM을 사용하면서 nginx가 필요없어졌다.
		- 이후 Blue/Green 무중단 배포를 하는데 proxy 설정이 필요하여 nginx를 사용하게 되었다.
	- Reverse Proxy 등 다양한 프록시 방식 설명
		- Revers Proxy
			- 클라이언트 요청을 대신 받아 백엔드 서버로 전달한다.
		- Forward Proxy
			- VPN 처럼 IP를 숨기고 외부 사이트에 접근한다.
		- Cashing Proxy
			- 정적파일이나 API 응답을 캐싱
- JWT
	- 세션 인증 방식과의 차이점?
		- 쿠키를 이용하여 사용자를 식별할 수 있는 값을 암호화하여 주고받는다.
		- JWT만으로 인증을 할 수 있다.
	- JWT의 만료 시간을 어떻게 설정했나요? 보안을 어떻게 강화했나요?
		- access Token의 시간을 짧게 refresh Token의 시간은 길게 설정하였습니다.
- Docker
	- VMware와의 차이점?
		- 커널 영역을 공유하여 더 가볍고 빠른 성능을 낸다.
		- Host와 같은 운영체제를 사용해야한다.
	- Docker를 사용한 이유?
		- 개발환경과 운영환경을 쉽게 일치시키기 위해서 사용했습니다.
		- 배포 과정에서 롤백시 image로 쉽게 롤백을 하기 위해 사용했습니다.
		- 운영 환경을 코드로 관리할 수 있는 장점이 있다.
	- Docker에서 이미지 최적화를 위해 어떤 방법을 사용했나요?
		- 초기에 java build 부터하는 image를 만들었는데 CD의 속도가 매우 느려 java build는 따로하여 jar를 복사하여 image build를 하는 형식으로 변경했습니다.
		- Layer Cashing을 사용하여 재사용할 수 있게 했습니다.ㅣ
- HTTPS
	- https를 적용한 이유?
	- https 통신 원리 설명
	- SSL 인증서를 어떻게 발급받고 적용했나요?
	- TLS handshake 과정에 대해 설명해주세요.
- 무중단 배포
	- 무중단 배포 방식 설명
	- Blue-Green Deployment와 Rolling Deployment의 차이점은 무엇인가요?
	- 무중단 배포 시 발생할 수 있는 문제를 어떻게 해결했나요?
- 모니터링
	- CloudWatch를 사용한 이유?
	- 확인한 지표?
	
