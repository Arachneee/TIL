- Java
	- java 17 버전을 사용한 이유? (11, 21 과의 차이점)
		- LTS로 안정적이고 장기적 지원을 해준다.
		- 널리 사용되는 버전으로 검증된 버전이다.
		- Records를 통해 DTO를 더 효율적으로 사용할 수 있다.
		- Spring Boot 3.xx 버전과의 호환성의 최신 기술과 성능을 최대한 활용할 수 있다.
- Spring Boot
	- 버전 3을 사용한 이유? (2와의 차이점)
		- 차이점 : Java17 이상을 요구함, Jakarta EE 9로 전환
		- GraalVM Native Image 지원으로 애플리케이션 시작 시간 단축, 메모리 사용량 최적화
	- Spring Boot를 사용한 이유? (Spring 과의 차이)
		- Auto-configuration
			-  @SpringBootApplication : 빈 자동 등록
			- 의존성 관련 필요한 빈 자동 등록
		- 내장 웹서버
		- 개발 속도와 배포 간편성 향상
		- 스타터 패키지 제공
		- Actuator 제공
	- Spring Boot Actuator를 사용해본 적이 있나요? 어떤 모니터링 지표를 확인했나요?
		- Health check를 이용한 로드밸런싱
		- 힙메모리 사용량
			- 이미지 업로드
		- GC 초당 발생횟수
			- 이미지 업로드
		- Http 요청 응답 시간
			- 성능측정
		- CPU 사용량
		- 스레드 풀 상태
- Spring 을 사용한 이유
	- 생산성
	- 확장성
		- DI와 AOP로 쉽게 유지보수하고 확장할 수 있다.
	- 안정성
- JPA
	- JPA를 사용한 이유? (Mybatis나 Spring JDBC와의 차이점)
		- 데이터베이스 작업의 단순화
		- 객체지향 개발 지원
			- Hibernate의 cascade, orphanremoval 등의 기능을 활용해서 객체 관점에서 코드를 작성하기 용이했다.
		- Lazy, Eager로 성능최적화
	- N+1 문제를 해결한 경험이 있나요? 어떻게 해결했나요?
		- 조회시 쿼리가 100번나가는 문제가 있었는데 1번으로 줄였다. 
		- fetch join을 사용해서 필요한 데이터를 한번에 가져올 수 있게 했습니다.
		- batch size를 조절하여 필요한 데이터를 in 절로 한번에 가져올 수 있게 했습니다.
	- Lazy Loading과 Eager Loading 차이점은 무엇인가요?
		- 필요한 시점에 쿼리를 날리는 방식
		- 즉시 쿼리를 날려서 가져오는 방식
	- JPA에서 Entity Lifecycle에 대해 설명할 수 있나요?
		- 비영속
		- 준영속
		- 영속
		- 삭제
- Mysql
	- RDBMS를 사용한 이유? 
		- 데이터의 무결성을 위해 사용했다.
		- ACID
			- 원자성 : 모든 작업이 완전히 실행되거나 전혀 실행되지 않아, 실패 시 데이터의 일관성을 유지할 수 있습니다.
			- 일관성 : 트랜잭션 실행 전후로 데이터베이스가 항상 일관된 상태를 유지합니다.
			- 고립성 : 동시에 여러 트랜잭션이 실행되더라도 서로 간섭하지 않으며, 독립적으로 처리됩니다.
			- 지속성 : 트랜잭션이 성공적으로 완료된 후에는, 시스템이 다운되더라도 데이터는 영구적으로 저장됩니다.
	- Mysql을 사용한 이유? (Oracle이나 Postgres와의 차이점)
		- Oracle은 비용이 높다.
		- 읽기 중심 어플리케이션에서 최적화
		- Mysql이 Postgres보다 쓰기 성능이 좋다.
	- 인덱스 최적화를 어떻게 했나요?
		- 커버링 인덱스를 사용하여 디스크 I/O를 최소화 한다.
		- 카디널리티가 높은 컬럼을 첫번째에 두기
	- 쿼리 성능 개선을 위해 어떤 방법을 사용했나요?
		- 쿼리 실행 계획을 분석해서 조인 쿼리를 서브쿼리로 변경했다.
- CI/CD
	- CI가 필요한 이유?
		- 자동화된 테스트를 통해 오류를 빠르게 판단할 수 있다.
		- 빠른 코드 통합에 도움을 준다.
		- 4명이서 개발을 할 때 서로 코드리뷰를 하기에 시간이 부족한 경우가 있었다. 이때 CI를 통해 코드에 에러는 없다는 것을 1차적으로 검증할 수 있어서 협업에 용이했다.
		- 또한 작은 실수도 자동화 테스트를 통해 잡을 수 있어 빠른 피드백에 도움을 주었다.
		- 생산성 향상에 도움을 주었다.
	- CD가 필요한 이유?
		- 매번 인스턴스에 접근해서 배포하는 것의 불편함을 느꼈습니다.
		- 빠른 배포 자동화로 기능을 추가하고 피드백 받는 사이클을 줄였습니다.
	- github Actions를 사용한 이유? (젠킨스, CodeDeploy와의 차이점)
		- 빠른 MVC를 개발해야하는 상황에서 러닝커브가 적고 빠르게 구축할 수 있는 github actions를 선택했습니다.
		- 젠킨스의 경우 훨씬 규모가 큰 프로젝트에서 복잡한 파이프라인을 구성해야할 때 좋다.
		- Code Deploy는 AWS 인프라와의 통합에 유리하고 무중단 배포, 롤백 기능을 제공하여 간편하다.
	- Github Actions에서 멀티스테이지 파이프라인을 구성한 경험이 있나요?
		- github actions로 블루그린 무중단 배포를 구성한 경험이 있습니다.
	- CI/CD 파이프라인을 어떻게 구성했나요?
		- github actions를 사용하여 CI는 테스트 코드를 돌리게하였습니다.
		- CD는 github actions에서 build 후 docker image로 build후 docker hub에 올린다.
		- ec2에서  docker hub 에서 image를 pull 받은 후 컨테이너를 실행시킨다.
- AWS
	- CloudFront를 사용한 이유?
	- ALB를 사용한 이유?
	- ALB와 NLB의 차이점은 무엇인가요?
	- S3를 사용한 이유?
	- S3에서 데이터의 내구성과 가용성을 어떻게 보장하나요?
	- VPC가 무엇인지?
	- VPC Peering을 설정한 경험이 있나요?
	- 서브넷이 무엇인지?
	- NAT이 무엇인지?
	- EC2를 여러대 사용한 이유?
	- READ / WRITE db를 분리한 이유?
	- Auto Scaling을 어떻게 구성했나요?
- Nginx
	- nginx를 사용한 이유?
	- Reverse Proxy 등 다양한 프록시 방식 설명
- JWT
	- 세션 인증 방식과의 차이점?
	- JWT의 만료 시간을 어떻게 설정했나요? 보안을 어떻게 강화했나요?
	- JWT 토큰 재발급을 어떻게 처리했나요?
- Docker
	- VMware와의 차이점?
	- Docker를 사용한 이유?
	- Docker에서 이미지 최적화를 위해 어떤 방법을 사용했나요?
- HTTPS
	- https를 적용한 이유?
	- https 통신 원리 설명
	- SSL 인증서를 어떻게 발급받고 적용했나요?
	- TLS handshake 과정에 대해 설명해주세요.
- 무중단 배포
	- 무중단 배포 방식 설명
	- Blue-Green Deployment와 Rolling Deployment의 차이점은 무엇인가요?
	- 무중단 배포 시 발생할 수 있는 문제를 어떻게 해결했나요?
- 모니터링
	- CloudWatch를 사용한 이유?
	- 확인한 지표?
	
