### 아루
- 아루가 생각하는 좋은 코드의 정의는 뭔가요?
- 테스트 격리 Extension을 사용한 것은 truncate를 사용하신건가요?
	- 만약 프로젝트 크기가 커서 테스트용 초기데이터가 있다면 truncate를 사용할수있을까요?
		- 없다면 어떻게 테스트를 격리해야할까요?
- RestDocs를 사용하면 테스트코드를 통과시키기 전까지 API문서를 제공하지 못할 것 같은데 어떻게 하셨나요?

### 레모네
- 그라파나에서 어떤 지표를 주로 확인하시나요?
	- 해당 지표가 어느정도되면 문제가 있다고 인식할 수 있을까요?
		- 그럼 어떤 조치를 취해야할까요?
- CD를 수행하지 않았다면 언제 배포를 하셨나요?

### 리브
- github actions와 codepipeline을 비교했을 때 codepipeline 은 어떤 장점이 있나요?
- 도커를 사용하신 것 같은데 도커로 어떤 컨테이너를 띄워서 사용하셨나요?
	- 컨테이너가 1개라면 도커 컴포즈를 사용하는 의미가 있나요?
	- 컨테이너가 여러개라면 CD시에 전체 컨테이너를 다시 띄우나요?
- Http를 Https로 리다이렉트 시키는 http status 코드는 몇인가요?
	- 301과 308의 차이를 아시나요?


---
학습

CORS
csrf 공격을 막기 위함
Cross-Origin Resource Sharing. 다른 사이트에서 요청을 보내는 경우 자원 공유를 서버가 허용해주는 Http 헤더 기반 메커니즘. 
Preflight : OPTIONS로 사전 요청을 보내 서버는 실제 요청 파라미터로 요청을 보내는 것이 적절한지 응답한다.
Access-Control-Allow-Credentials: true 를 포함하지 않으면 서브파티 쿠키같은 자격증명 요청을 수행할 수 없다.

  

쿠키

Domain : 쿠키를 보낼 호스트를 지정한다. 서브 도메인도 포함한다.

Expires : 쿠키의 최대 생명주기, 없으면 세션 쿠키로 동작 

HttpOnly : javaScripts가 쿠키에 접근하는 것을 제한

Max-Age : 쿠키가 만료할 때까지의 초. Expires보다 우선순위를 가진다.

Path : url 에 접근할 수 있는 경로

SameSite :  사이트 간 요청에 쿠키가 전달될지 제어하여 CSRF 에 대한 보호를 제공.

None : 다른 사이트 간에 쿠키를 전달할 수 있음. secure 옵션이 true여야 함.

Lax : 다른 사이트 간에 쿠키를 전달하지 않음. 링크에 의한 이동에만 쿠키 전달. default

Strict : 같은 사이트만 쿠키 전달가능.

Secure : https로만 쿠키 전달 가능 (localhost 제외)

  

CI/CD

코드 릴리스 주기가 단축을 위해 지속적인 통합과 지속적인 배포 파이프라인을 구축했습니다.

github actions, docker를 사용하여 CI/CD 파이프라인을 구축했습니다.

github actions를 사용한 이유는 젠키스 등 다른 툴보다 학습곡선이 낮고 github actions를 경험해본 팀원이 많아 빠르게 도입할 수 있다고 판단했기 때문입니다.

docker를 사용한 이유는 운영서버와 개발서버의 환경을 동일하게 구성하기 위해서 사용했습니다. docker image로 컨테이너를 띄워 환경을 동일하게 유지하면 장애에 대한 변수를 줄였습니다.

  
  

협업

내가 생각하는 협업 : 내 등을 팀원에게 믿고 맡길 수 있는 상태로 일하는 것. 팀원간의 신뢰가 협업에 있어 가장 중요하다고 생각합니다. 사람을 잘 믿지 못하고 사람에게 관심을 기울이는 것이 부족하여 팀원들과 신뢰를 쌓기 어려웠습니다. 그래서 이번 프로젝트 동안 팀원에게 관심을 가지는 것을 목표로 노력했습니다. 예를 들어, 팀원이 뿌염을 언제 했는지, 어떤 야채를 안 먹는지 알아보며 친밀도를 쌓았습니다. 그렇게 노력하다보니 어느 순간 편하게 부탁할 수 있는 관계가 되었습니다. 서로가 서로를 신뢰하기 때문에 편하게 모르는 것을 물어보고 필요한 것을 부탁할 수 있었던 것 같습니다. 편하게 부탁할 수 있는 관계는 팀 프로젝트의 생산성을 높였고 한 팀으로 같은 목표를 바라보는데 도움을 주었습니다.

  

협업하는데 중요하다고 생각하는 것 : 상대방의 입장을 이해하는 것. 프로젝트 초기에 프론트엔드의 작업속도가 느린 이유가 이해되지 않았습니다. 또한 기획을 생각할 때 의견이 다른 부분이 많았습니다. 상대방의 입장을 생각하기 위해 팀원들에게 프론트, 백 역할을 바꿔서 작업을 해보자고 제안하여 프론트엔드 작업 경험해봤습니다. 직접 프론트엔드 작업을 진행하며 디자인시스템, 컴포넌트 구성 등 해야할 일이 정말 많다는 것을 알게되었습니다. 이 경험으로 상대방을 조금 이해할 수 있었고 기획부분에서도 프론트엔드 개발자가 화면 전환에 더 신경을 쓰는 모습을 이해할 수 있었습니다.

**

---
자신있게 알고 있는 용어를 가지고 말해라.
논리와 이유가 있으면 좋다.
핵심만 전달하며 꼬리 질문을 받아라
그림을 그릴때 설명을 하면서 그리면 인터뷰어를 지루하지 않게 할 수 있다.

싱글쓰레드가 대용량 트래픽을 감당할 수 있는 이유?
JPA캐시 1차 캐시, 2차캐시


코드가 jvm 스택, 힙 영역에 어떻게 쌓이고 가비지 콜렉팅 되는지?


### 아루
- 서비스 소개
	- 리뷰미 개발자가 알아가는 것이 중요하다. 나의 강점을 상호피드백으로 자신을 아는 서비스
- 좋은 코드를 위해 객체지향이라고 느낀 이유?
	- 레벨 1,2에 객체지향을 신봉하다가 레벨3에 패러다임의 불일치를 해결하고 싶었다. 연관관계를 끊어서 유지보수를 더 좋게 만들어 객체지향이 좋은 코드만이 아니다라는 것을 알게되었다.
- api문서 다른 대안이 있었는지?
	- api를 통보하는 문제가 있었다. open api 등을 사용하려다가 러닝커브를 고려해 안하게 되었다. rest docs에서 mocking을 통해 작업전에 

- reviewme.page를 쳤을 때 일어나는 일 최대한 구체적으로.
	- dns server 요청 
	- ip응답
	- 라우터를 거쳐 서버에 들어온다.
	- nginx가 응답을 받는다.
	- 톰켓 서버로 80 -> 8080으로 들어오게된다.
	- controller를 찾아서 리소스를 반환한다.
- 정적페이지 잘못 선택한 것 아닌가?
- 동적페이지도 cloudfront로 가는가?
- 톰켓 dispatcher servlet에서 controller를 거쳐 db까지 거치는 과정 설명
	- request -> handlerMapper 가 적절한 handler를 찾는다. -> controller에서 service 검증 진행 -> repository에서 데이터를 받아온다. -> 다시 반환해서 http로 반환한다.
- 비지니스 로직이 어디에 위치하는지?
	- 도메인을 방어적으로 사용하고 있다.
	- 유연한 도메인을 만들기 위해 서비스에 위치시켰다.
- 로깅, 모니터링에 무엇을 사용했는지?
	- 엑츄레이터, 로키, 그라파나, 프로메테우스 로 확인하고 있다.
	- 솔직하게 로깅을 모르는 상황에서 선택하게되었다. 많은 선택지 중에  elk보다 간편하다. 오픈소스다 라는 점에서 선택하게 되었다.
- 로깅에서 누가 언제 무엇을 파악할 수 있는 상태인가?
	- 현재 안되어있다.
- 앞으로 할 계획인가?
	- 로그로 찍을 생각이다.
	- 협의 중이다.
	- 나는 하고 싶다.
- 싱글쓰레드인데 어떻게 더 많은 트래픽을 감당할 수 있을까?
	- 멱등성이 보장되는 요청은 제한이 없지만 멱등성이 보장되지 않는 것은 생각해봐야한다.
- 멱등성도 데이터 베이스를 찌르는데 어떻게 감당이 가능한가?
	- 추측은 waiting을 하면 감당할 수 없다.
	- 주기적으로 요청이 준비되었는지 물어본다.
- 