`@RestClientTest` 와 `MockRestServiceServer` 

RestClient.Builder 가 빈에 등록되어있다.
builder에 바로 errorHandler를 세팅하면 Mocking이 되지 않는다.
RestClientCustomizer 를 사용하여 빈으로 등록하면 Mocking을 사용할 수 있다.

```java
@Bean  
public RestClient restClient(RestClient.Builder restClientBuilder) {  
    return restClientBuilder.build();  
}  
  
@Bean  
public RestClientCustomizer restClientCustomizer() {  
    return (restClientBuilder) -> restClientBuilder  
            .requestFactory(clientHttpRequestFactory())  
            .baseUrl("https://api.tosspayments.com")  
            .defaultHeader("Authorization", createAuthorizationHeader())  
            .defaultStatusHandler(responseErrorHandler());  
}
```

MockRestServiceServer가 RestClient 의 요청에 응답할 수 있다.

```java
@RestClientTest(value = PaymentClient.class)  
@Import(PaymentConfig.class)  
class TossPaymentClientTest {  
  
    @Autowired  
    private PaymentClient paymentClient;  
  
    @Autowired  
    private MockRestServiceServer mockRestServiceServer;  
  
    @DisplayName("결제 승인이 정상 처리된다.")  
    @Test  
    void success() {  
        // given  
        PaymentRequest paymentRequest = new PaymentRequest(1000, "orderId", "paymentKey");  
  
        mockRestServiceServer.expect(requestTo("https://api.tosspayments.com/v1/payments/confirm"))  
                .andRespond(withSuccess());  
  
        // when // then  
        assertThatCode(() -> paymentClient.requestApproval(paymentRequest))  
                .doesNotThrowAnyException();  
    }
```

mockRestServiceServer가 외부 서버의 역할을 모킹하여 테스트 할 수 있다.


`@Retryable` 재시도

백엔드 개발자란 무엇인가?

1단계에서 구현한 로직를 시퀀스 다이어그램 형태로 그려본다.

cmd + L : 검색창 바로가기
cmd + T : 새탭 열기
cmd + W : 탭 닫기
cmd + 화살표 : 앞으로 가기 뒤로가기

