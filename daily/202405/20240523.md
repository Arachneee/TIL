> [!NOTE]
> 저의 생각을 먼저 말씀 드리면 저는 가능한 연관관계를 맺지 않는 것을 좋아합니다.
> 
> jpa 라는 특별한 라이브러리에 도메인 기능이 종속적이게 되는 것에 불편한 경험이 많기 때문입니다.  
> 애플리케이션의 요구사항은 예상치 못한 방향으로 변경되기도 하는데 기존 정책을 뒤집어야 하는 경우도 있습니다. 이러한 경우 jpa의 특정 영속성 컨텍스트를 이용하는 기능을 사용했다가 변경에 어려움을 겪은적이 있습니다.
> 
> 그렇다면 절대 사용하지 않느냐? 라고 묻는다면 그렇지는 않습니다.
> 
> 명백히 생명주기가 일치하는 케이스라면 사용하기도 합니다.
> 
> 조금 더 풀어서 말하면 생성되는 시기와 제거되는 시기가 언제나 동일하다면 연관관계로(OneToMany) 묶어서 사용하곤 합니다.
> 
> 이러한 경우라면 cascade와 같은 속성을 사용해도 크게 이질감 없이 사용할 수 있기 때문입니다.
> 
> 위 말씀을 토대로 다시 정리해보자면, 저는 jpa도 하나의 외부 라이브러리로 바라보고 있기 때문에  
> 도메인이 해당 라이브러리에 의존하는것을 그다지 선호하는 편이 아닙니다.
> 
> 도메인은 가능한 POJO하게 작성하는게 좋다고 생각하는 편이라 기회가 있다면 도메인용 객체와 영속성 컨텍스트용 객체 또한 분리하는 편입니다.

---

POJO가 뭘까?
> **진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고**  
**필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트 feat. 토비

---

안녕하세요 비밥!
백호입니다. 양방향연관관계에대해 더 이야기하고 싶어서 DM드려요.
시간 되실때 답변주셔도 괜찮습니다. 😊

> 명백히 생명주기가 일치하는 케이스라면 사용하기도 합니다.

> 각 테이블이 가지고 있는 데이터의 목적 혹은 생명주기가 달라지면 테이블을 나누는 것이 좋다고 생각하는 편입니다.

##### 질문1. 예약과 예약 대기는 생명주기가 같다고 생각하시나요? 다르다고 생각하시나요?
저는 예약과 예약대기를 한 테이블에 둬도 괜찮다고 생각할 만큼 같다고 생각합니다.
만약 다르다고 생각하신다면 정말 생명주기가 같은 경우가 존재하는지 모르겠습니다. 예시가 있을까요?

> [!NOTE]
> 답변1.  
> 
> 생명주기가 같다면 Reservation이 제거될 때 연관된 Waiting도 한꺼번에 제거되어 문제가 없어 보여야 합니다. 그리고 백호가 작성해주신 코드를 보았을때 orphanRemoval이 true로 설정되어있어서 Reservation이 제거 될 때 연관된 Waiting이 함께 제거될 것 같이 보입니다. 그런데 service에 표현되어있는 비즈니스 흐름(cancelReservation)을 보았을때 reservation.hasNotWaiting이 만족되어야먄 reservation이 delete 되는 것으로 보입니다. waiting이 있는 상태에서 reservation이 delete 되면 안되기 때문에 이렇게 작성해주신것 같은데 맞을까요? 이러한 부분을 보았을때 생명주기가 같은것이라 볼 수 있는가라는 물음표가 생기는 것 같습니다.
> 
> 제가 다루는 도메인에서 생명주기가 같은 경우는 회원과 회원의 정보인데요.
> 회원이 생성되기 위해서는 회원의 개인정보도 별도로 수집 및 보관을 하고 있습니다.
> (왜 따로 데이터를 보관하는지에 대한 의문이 드실 수 있는데… 이 부분은 분리하지 않으면 도메인 복잡도가 높아지기 때문이다 라고밖에 설명을 드리지 못하겠네요.)
> 그리고 회원이 제거될때 개인정보도 반드시 함께 삭제가 되어야만 합니다. 이러한 경우에는 생명주기가 일치한다고 봅니다.

>jpa도 하나의 외부 라이브러리로 바라보고 있기 때문에 도메인이 해당 라이브러리에 의존하는것을 그다지 선호하는 편이 아닙니다. 

##### 질문2. 그럼 JPA의 변경감지도 선호하시지 않나요 ?

> 도메인은 가능한 POJO하게 작성하는게 좋다고 생각하는 편이라 기회가 있다면 도메인용 객체와 영속성 컨텍스트용 객체 또한 분리하는 편입니다.

저도 도메인은 POJO하게 작성하는 것이 좋다고 생각합니다. 그런데 저는 POJO하게 작성하는 것이 레벨1때처럼 도메인이 자신의 역할을 가질 수 있도록 설계하여 도메인을 다른 환경에서 재사용할 수 있게 하는 것이라 생각합니다. 
그래서 현재 구조가 더 POJO 가깝다고 생각합니다. 오히려 JPA의 영속성전이, 변경감지 등의 기능이 도메인을 POJO로 작성할 수 있게 도와주는 것이라고 생각합니다.
JPA의 기능을 활용하지 않으면 Service에서 비지니스 로직을 Repository와의 순차적인 소통으로 표현해야합니다. 이러한 방식을 트랜잭션 스크립트 패턴이라고 하더라고요.
저는 JPA기능을 활용하여 스크립트 패턴으로 표현된 로직을 도메인 모델 패턴으로 바꾸는 것이 더 객체지향적인 설계이고 유지보수에 좋다고 생각합니다.

> [!NOTE]
> 답변2.  
> 
> JPA의 더티체킹 사용합니다. 이 기능없으면 아시다시피 쿼리를 수기로 작성해주어야 하는데 생산성 지옥이죠.
> 
> 트랜잭션 스크립트는 도메인 로직이 절차적인 형태로 service layer에 노출된것을 의미하지 service와 repository를 순차적으로 소통하는것이 아니라고 알고있습니다. 따라서 JPA를 사용하지 않으면 트랜잭션 스크립트 패턴으로 작성된 코드라고 보기에는 조금 무리가 있을것 같습니다. 반대로 JPA가 없던 시절에는 모두 트랜잭션 스크립트 패턴으로 작성했을까요?
> 
> 그리고 jpa를 사용하는데 mysql과 같은 rdb에서 mongodb과 같은 nosql로 변경되는 경우 더티체크가 동작하지 않습니다. (실제로 데이터가 쌓이는 양이 많으면 변경되는 경우가 있습니다. ex. 주문 데이터) 이러한 경우 더티체크를 기반으로 작성한 도메인 서비스 코드가 올바르게 동작한다고 보장할 수 있을까요?
> 
> 저는 그래서 service 레이어의 코드 또한 pojo하게 작성하는 것을 선호하는편입니다.
> 그래서 서비스의 결과로 데이터가 변경되어야 하면 명시적으로 save를 호출해줍니다. 이렇게 하면 service에 표현된 코드는 save가 보장되어야 한다는 것을 알 수 있기때문입니다.  service코드를 POJO에 가깝게 작성하는게 아닌 정말 POJO하게 작성하는것입니다. 그 상태에서 인터페이스 구현체들을 변경해도 동일한 기대값을 얻을 수 있도록 인터페이스를 설계하는 것입니다.
> JPA를 사용하시는 것은 좋습니다. 편리하고 좋은 기능이 많으니까요. 그런데 너무 JPA specific 하게 문제를 해결하시지 않을까 하여 남긴 리뷰였는데 JPA의 특정기능을 아예 사용하지 않는것으로 유도한것 같은 오해가 조금 있는것 같네요.

> jpa 라는 특별한 라이브러리에 도메인 기능이 종속적이게 되는 것에 불편한 경험이 많기 때문입니다. 
> 애플리케이션의 요구사항은 예상치 못한 방향으로 변경되기도 하는데 기존 정책을 뒤집어야 하는 경우도 있습니다.

도메인이 JPA의 기능에 종속된다는 것에는 동의합니다. 하지만 기존 정책을 뒤집어야 하는 경우는 양방향관계 때문만은 아니라고 생각합니다. 오히려 요구사항이 180도 바뀌는 경우가 아니라면 도메인에 도메인 로직이 들어 있는 형태가 되어야 변경하기 더 쉽다고 생각합니다. 

##### 질문3. 그래도 JPA의 기능을 활용하는 것이 더 유지보수에 어렵다고 생각하시나요?

> [!NOTE]
> 답변3.  
> 
> 제가 JPA를 엄청 싫어한다고 생각하시는 것은 아니지요..?
> 당연히 JPA를 활용하면 유지보수에 큰 도움이 되지요.
> 기존 정책을 뒤집어야하는 경우가 양뱡향 관계 때문이 아니라, 기존 정책을 뒤집어야 하는데 양방향 관계가 정책을 뒤집는 작업을 할 때 불편함을 준적이 있다는 것입니다.

비밥! 답변 감사합니다. 😊
생명주기가 같은지 다른지 판단하는 것이 정말 어렵네요.

> 대표적으로 생명주기가 일치하지 않는 entity간의 참조는 id로 끊어서 가져가는 것이 좋다는 이야기가 많이 있습니다.

Reservation과 Member의 생명주기가 다르다는 것은 알겠습니다. id로 끊어서 가져가는 것이 좋다는 것도 어느정도 이해가 되고요. 그런데 Reservation과 Waiting도 생명주기가 다르다면 id로 끊어서 가져갈 만큼 다른가? 라는 생각도 드네요.

그리고 도메인 정책과 도메인 구조에 따라 엔티티의 생명주기가 달라 질 수 있는 것 같아요.
##### 질문1. 댓글과 대댓글은 양뱡향관계를 사용하여 설계를 하곤 했습니다. 그런데 대댓글이 있으면 댓글을 삭제하지 못하는 정책이 생긴다면 더 이상 생명주기가 같을 수 없으므로 양뱡향관계를 사용하지 말아야 할까요?

##### 질문2. 비밥은 설계할 때 생명주기의 동일성을 어떻게 판단하시나요?

##### 질문3. 저의 예약 대기 객체를 설계하는 사고 흐름이 잘못되었을까요?
저는 기존 1,2 단계의 Reservation 객체에서 예약 대기자가 추가 되면 `List<Member>` 만 필드로 추가되면 된다고 생각했습니다. 그래서 다음과 같은 구조가 나왔어요.
```java
public class Reservation {
	private Long id;
	private Member member;
	private ReservationTime time;
	private LocalDate date;
	private Theme theme;
	private List<Member> waitingMembers;
	...
}
```

그런데 waitingMembers의 Member는 Reservation과 N:N 관계가 되기 때문에 중간 객체가 필요했어요.
그래서 중간 객체를 Waiting으로 설정하고 Reservation의 `List<Member>`는 `List<Waiting>`이 되었어요.
그래서 양방향관계가 되었습니다. 

양방향관계의 순환참조는 문제가 될 수 있기 때문에 처음에는 사용하지 않았습니다. 그런데 Service 객체가 뚱뚱해진 것을 해결할 수 있는 방법을 찾다 양방향관계를 다시 사용했습니다. Service 객체가 날씬해 진 것에 굉장히 만족하고 있고 진짜 양뱡향이 문제가 될지 아직 모르겠어요. 물론 무분별하게 사용하는 것은 경계하고 있습니다. 더 경험이 쌓이면 알게 될 것 같습니다.


